This chapter introduces procedures, subroutines, and functions. A ***procedure*** is a block of code with a clearly marked beginning and end, that when called from some other place in a program, returns to its calling point when completed. Any program of reasonable size needs to be divided into parts, and certain parts need to be used more than once. Parameters can be passed in registers, and the CPU uses the runtime stack to track the calling location of procedures. Finally, two code libraries supplied, named Irvine32 and Irvine64, contain useful utilities that simplify input-output.

**Previous Chapter**: [[4. Data Transfers, Addressing, and Arithmetic]]

# 5.1 Stack Operations

A ***stack data structure*** follows the same principle as a stack of plates:
- New data values are added to the top of the stack.
- Existing values are removed from the top of the stack.
Stacks in general are useful structures for a variety of programming applications, and they can easily be implemented using [object-orientated programming methods](https://en.wikipedia.org/wiki/Object-oriented_programming). A stack is often called a **LIFO structure** (Last-in, First-out) because the last value put into the stack is always the first value taken out.

## Runtime Stack (32-Bit Mode)

The ***runtime stack*** is a memory array managed directly by the CPU, used to keep track of subroutine return addresses, procedure parameters, local variables, and other subroutine-related data.

In 32-bit mode, the ESP register, known as the ***stack pointer***, holds a 32-bit offset into some location on the stack. We rarely manipulate ESP directly; instead, it is indirectly modified by instructions such as `CALL`, `RET`, `PUSH`, and `POP`.

ESP always points to the last value to be added to, or *pushed* on, the top of stack. 

![[img13.png]]

Each stack location in this figure contains 32-bits, which is the case when a program is running in 32-bit mode.

### Push Operation

A ***push operation*** decrements the stack pointer (because the stack grows downward) by the appropriate amount according to the instruction operand's size and copies a value into the location in the stack referenced by the stack pointer.

Note that ESP register always points to the last item pushed on the stack.

![[img14.png]]

### Pop Operation

A ***pop operation*** returns a copy of the value in the stack referenced by the stack pointer and increments the stack pointer by the appropriate amount according to the size of the instruction operand.

After the value is popped from the stack, the stack pointer is incremented to point to the next-highest location in the stack.

![[img15.png]]

### Stack Applications

- A stack makes a convenient temporary save area for registers when they are used for more than one purpose. After they are modified, they can be restored to their original values.
- When the `CALL` instruction executes, the CPU saves the current subroutine's return address on the stack.
- When calling a subroutine, you pass input values called **arguments** by pushing them on the stack.
- The stack provides temporary storage for local variables inside subroutines.

## PUSH and POP Instructions

### PUSH Instruction

The `PUSH` instruction first decrements ESP and then copies a source operand into the stack. A 16-bit operand causes ESP to be decremented by 2. A 32-bit operand causes ESP to be decremented by 4.

```
PUSH reg/mem16
PUSH reg/mem32
PUSH imm32
```

*Note*: 8-bit (1 byte) values cannot be pushed onto the stack.

### POP Instruction

The `POP` instruction first copies the contents of the stack element pointed to by ESP into a 16 or 32-bit destination operand, and then increments ESP. If the operand is 16 bits, ESP is incremented by 2; if the operand is 32 bits, ESP is incremented by 4.

```
POP reg/mem16
POP reg/mem32
```

### PUSHFD and POPFD Instructions

The `PUSHFD` instruction pushes the 32-bit EFLAGS registers on the stack and `POPFD` pops the stack into EFLAGS.

```
pushfd
popfd
```

The `MOV` instruction cannot be used to copy the flags to a variable, so `PUSHFD` may be the best way to save the flags. There are times when it is useful to make a backup copy of the flags so you can restore them to their former values later. Often, we enclose a block of code within `PUSHFD` and `POPFD`:

```
pushfd     ; save the flags
...
...
popfd      ; restore the flags
```

A less error-prone way to save and restore the flags is to push them on the stack and immediately pop them into a variable.

```
.data
saveFlags DWORD ?
.code
pushfd          ; push flags on stack
pop saveFlags   ; copy into a variable
```

