This chapter introduces a major item, giving programs the ability to make decisions. Introduction to Boolean operations are given, which are the core of all decision statements because they affect the CPU status flags. Use of conditional jump and loop instructions that interpret CPU status flags is shown.

A programming language that permits decision making lets you alter the flow of control, using a technique known as ***conditional branching***. Every `if` statement, `switch` statement, or conditional loop found in high level languages has built-in branching logic.

Programs that deal with hardware devices must be able to manipulate individual bits in numbers. Individual bits must be tested, cleared, and set. Data encryption and compression also rely on bit manipulation.

**Previous Chapter**: [[5.  Procedures]]

# 6.1 Boolean and Comparison Instructions

The intel instruction set contains the `AND`, `OR`, `XOR`, and `NOT` instructions, which directly implement Boolean operation on binary bits. In addition, the `TEST` instruction is a nondestructive Boolean `AND` operation.

| Instruction | Description |
| :-: | :-- |
| `AND` | Boolean `AND` operation between a source operand and a destination operand. |
| `OR` | Boolean `OR` operation between a source operand and a destination operand. |
| `XOR` | Boolean `XOR` operation between a source operand and a destination operand. |
| `NOT` | Boolean `NOT` operation on a destination operand. |
| `TEST` | Implied Boolean `AND` operation between a source and destination operand, setting the CPU flags appropriately. |

## The CPU Status Flags

- The **Zero flag** is set when the result of an operation equals zero.
- The **Carry flag** is set when an operation generates a carry out of the highest bit of the destination operand.
- The **Sign flag** is a copy of the high bit of the destination operand, indicating that it is negative if *set* and positive if *clear*, where zero is assumed to be positive.
- The **Overflow flag** is set when an instruction generates a result that is outside the signed range of the destination operand.

## AND Instruction

The `AND` instruction performs a Boolean (bitwise) AND operation between each pair of matching bits in two operands and places the result in the destination operand.

```
AND destination, source
...
AND reg, reg
AND reg, mem
AND reg, imm
AND mem, reg
AND mem, imm
```

The operands can be 8, 16, 32, or 64 bits, but they must be the same size.

| x | y | x ^ y |
| :-: | :-: | :-: |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

The `AND` instruction lets you clear 1 or more bits in an operand without affecting the other bits. This technique is called *bit masking*.

```
and AL, 11110110b  ; clear bits 0 and 3, leave others unchanged
```

### Flags

The `AND` instruction always clear the Overflow and Carry flags. It modifies the Sign, Zero, and Parity flags in a way that is consistent with the value assigned to the destination operand.

### Converting Characters to Uppercase

The `AND` instruction provides an easy way to translate a letter from lowercase to uppercase. If we compare the ASCII codes of capital **A** and lowercase **a**, it becomes clear that only bit 5 is different:

```
0 1 1 0 0 0 0 1 = 61h ('a')
0 1 0 0 0 0 0 1 = 61h ('A')
```

If we `AND` any character with 11011111b, all bits are unchanged except for bit 5, which is cleared.

```
.data
array BYTE 50 DUP(?)

.code
	mov ecx, LENGTHOF array
	mov esi, OFFSET array
L1:
	and BYTE PTR [esi], 1101111b ; clear bit 5
	inc esi
	loop L1
```

## OR Instruction

stopped at 577.