# 6. Conditional Processing

This chapter introduces a major item, giving programs the ability to make decisions. Introduction to Boolean operations are given, which are the core of all decision statements because they affect the CPU status flags. Use of conditional jump and loop instructions that interpret CPU status flags is shown.

A programming language that permits decision making lets you alter the flow of control, using a technique known as ***conditional branching***. Every `if` statement, `switch` statement, or conditional loop found in high level languages has built-in branching logic.

Programs that deal with hardware devices must be able to manipulate individual bits in numbers. Individual bits must be tested, cleared, and set. Data encryption and compression also rely on bit manipulation.

**Previous Chapter**: [[5.  Procedures]]

## 6.1 Boolean and Comparison Instructions

The intel instruction set contains the `AND`, `OR`, `XOR`, and `NOT` instructions, which directly implement Boolean operation on binary bits. In addition, the `TEST` instruction is a nondestructive Boolean `AND` operation.

| Instruction | Description |
| :-: | :-- |
| `AND` | Boolean `AND` operation between a source operand and a destination operand. |
| `OR` | Boolean `OR` operation between a source operand and a destination operand. |
| `XOR` | Boolean `XOR` operation between a source operand and a destination operand. |
| `NOT` | Boolean `NOT` operation on a destination operand. |
| `TEST` | Implied Boolean `AND` operation between a source and destination operand, setting the CPU flags appropriately. |

### The CPU Status Flags

- The **Zero flag** is set when the result of an operation equals zero.
- The **Carry flag** is set when an operation generates a carry out of the highest bit of the destination operand.
- The **Sign flag** is a copy of the high bit of the destination operand, indicating that it is negative if *set* and positive if *clear*, where zero is assumed to be positive.
- The **Overflow flag** is set when an instruction generates a result that is outside the signed range of the destination operand.

### AND Instruction

The `AND` instruction performs a Boolean (bit-wise) AND operation between each pair of matching bits in two operands and places the result in the destination operand.

```assembly
AND destination, source
...
AND reg, reg
AND reg, mem
AND reg, imm
AND mem, reg
AND mem, imm
```

The operands can be 8, 16, 32, or 64 bits, but they must be the same size.

| x | y | x & y |
| :-: | :-: | :-: |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

The `AND` instruction lets you clear 1 or more bits in an operand without affecting the other bits. This technique is called *bit masking*.

```assembly
and AL, 11110110b  ; clear bits 0 and 3, leave others unchanged
```

#### AND Flags

The `AND` instruction always clear the Overflow and Carry flags. It modifies the Sign, Zero, and Parity flags in a way that is consistent with the value assigned to the destination operand.

#### Converting Characters to Uppercase

The `AND` instruction provides an easy way to translate a letter from lowercase to uppercase. If we compare the ASCII codes of capital **A** and lowercase **a**, it becomes clear that only bit 5 is different:

```assembly
0 1 1 0 0 0 0 1 = 61h ('a')
0 1 0 0 0 0 0 1 = 61h ('A')
```

If we `AND` any character with 11011111b, all bits are unchanged except for bit 5, which is cleared.

```assembly
.data
array BYTE 50 DUP(?)

.code
 mov ecx, LENGTHOF array
 mov esi, OFFSET array
L1:
 and BYTE PTR [esi], 1101111b ; clear bit 5
 inc esi
 loop L1
```

### OR Instruction

The `OR` instruction performs a Boolean (bit-wise) OR operation between each pair of matching bits in two operands and places the result in the destination operand.

```assembly
OR destination, source
...
OR reg, reg
OR reg, mem
OR reg, imm
OR mem, reg
OR mem, imm
```

The operands can be 8, 16, 32, or 64 bits, but they must be the same size.

| x | y | x \| y |
| :-: | :-: | :-: |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

The `OR` instruction is particularly useful when you need to set 1 or more bits in an operand without affecting any other bits.

```assembly
or AL, 00000100b  ; set bit 2, leave others unchanged
```

#### OR Flags

The `OR` instruction always clear the Overflow and Carry flags. It modifies the Sign, Zero, and Parity flags in a way that is consistent with the value assigned to the destination operand.

For example, you can `OR` a number with itself (or zero) to obtain certain information about its value.

```assembly
or al, al
```

The values of the Zero and Sign flags indicate the following about the contents of AL:

| Zero Flag | Sign Flag | Value in AL is... |
| :-: | :-: | :-: |
| Clear | Clear | Greater than zero |
| Set | Clear | Equal to zero |
| Clear | Set | Less than zero |

### Bit-Mapped Sets

A ***bit-mapped set*** implements a one-to-one correspondence between a sequence of binary bits and set membership. Rather than holding pointers or references to objects in a container such as a [Java HashSet](https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html), an application can use a ***[bit vector](https://en.wikipedia.org/wiki/Bit_array)*** to map the binary number to an array objects.

For example, the following binary number uses bit positions numbered from 0 on the right to 31 on the left to indicate that array elements 0, 1, 2, and 31 are members of the set named **SetX**:

```assembly
SetX = 10000000 0000000 0000000 00000111
```

We can easily check for set membership and `AND`-ing a particular  member's bit position with a 1:

```assembly
mov eax, SetX
and eax, 10000b  ; is element[4] a member of SetX?
```

If the `AND` instruction in this example clears the Zero flag, we know element[4] is a member of SetX.

#### Set Complement

The complement of a set can be generated using the `NOT` instruction, which reverses all bits.

#### Set Intersection

The `AND` instruction produces a bit vector that represents the intersection of two set.

#### Set Union

The `OR` instruction produces a bit map that represents the union of two sets.

### XOR Instruction

The `XOR` instruction performs a Boolean (bit-wise) XOR operation between each pair of matching bits in two operands and places the result in the destination operand.

```assembly
XOR destination, source
...
XOR reg, reg
XOR reg, mem
XOR reg, imm
XOR mem, reg
XOR mem, imm
```

The operands can be 8, 16, 32, or 64 bits, but they must be the same size.

| x | y | x ^ y |
| :-: | :-: | :-: |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

#### XOR Flags

The `XOR` instruction always clear the Overflow and Carry flags. It modifies the Sign, Zero, and Parity flags in a way that is consistent with the value assigned to the destination operand.

#### Checking the Parity Flag

In x86 processors, the Parity flag is set when the lowest byte of the destination operand of a bit-wise or arithmetic operation has even parity. Conversely, when the operand has odd parity, the flag is cleared.
