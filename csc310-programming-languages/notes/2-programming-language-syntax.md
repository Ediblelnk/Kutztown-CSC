# 2. Programming Language Syntax

**Computer languages** must be *precise*. Both their **form** (syntax), and **meaning** (semantics) must be *specified without ambiguity*.

To provide the needed degree of *precision*, language designers and implementors *use formal syntactic and semantic notation*.

A **[context-free language](https://en.wikipedia.org/wiki/Context-free_language)** means that any part of the expression can be replaced with production rules, which don't change the meaning of the expression.

```unix
a -> cd
b -> eff
```

then

```unix
abba -> cdeffeffcd
```

**[Regular Language](https://en.wikipedia.org/wiki/Regular_language)**
**[Recursively Enumerable Languages](https://en.wikipedia.org/wiki/Recursively_enumerable_language)**

*Regular Language* (subset) *Context-free Language* (subset) *Recursively Enumerable Language*

Recursively Enumerable Language <--- recognized by a Turing Machine (TM)
Context-sensitive language
Context-free Language <--- recognized by a Context-free Grammar
Regular Language <--- recognized by a *Regular Expression*

## 2.1 Specifying Syntax: Regular Expression and Context-Free Grammars

Formal specification of **syntax** requires a **set of rules**. **Tokens** are the basic **building blocks** of programs: the shortest string of characters with **individual meaning**. For example keywords, identifiers, symbols, and constants of various types.

### Regular Expressions

To specify tokens, we use the notation of "**regular expressions**".

A regular expression is one of the following:

1. A *character*
1. The *empty string*, denoted by \epsilon or \lambda
1. Two regular expressions next to each other: *concatenation*
1. Two regular expressions followed by a **Kleen star**, meaning the concatenation of zer or more string generated by the expression in front of the star.

When you come up with a regular expression, make sure the regex identifies only the language, and nothing more, nothing less. It must be *exact*.

#### Examples

1. Let Alphabet = **{0,1}**
Language(**(0|1)*1(0|1)**) = {10,11,010,011,110,111,...}

1. Let Alphabet = **{a,b,c}**
Language(**(a|bc)*c**) = {c, ac, bcc, aac, bcbcc, abcc, bcac, ...}

1. Let Alphabet = **{0,1}**. Strings that consist of alternating 0s and 1s.
Regular Expression = **(0|\lambda)(10)*(1|\lambda)**

1. Let Alphabet = **{0,1}**. Strings that start with '01' and up with '11'.
Regular Expression = **01(0|1)\*11**

1. Let Alphabet = **{0,1}**. Strings that have at least three consecutive 0's, '000'.
Regular Expression = **(0|1)\*000(0|1)\***

identifier in *C++*: (\_|a|...|z|A|...|Z)(\_|a|...|z|A|...|Z|0|...|9)\*

number -> integer | real
integer -> digit digit*
real -> integer exponent | decimal (exponent | \lambda)
decimal -> digit* (.digit|digit.) digit*
exponent -> (e | E)(+|-| \lambda ) integer
digit -> 0|1|2|3|4|5|6|7|8|9
